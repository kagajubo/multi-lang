一、软件简介

      本软件支持生成多国文字非等宽显示点阵字库（由矢量字库转点阵字库)。可以自由生成任意字体、不同大小的点阵字库，主要应用在所有需要文字显示（点阵字库支持）的嵌入式系统中。
      特点： 转换速度非常快（秒级）,可以免费支持 16 点阵字库的转换。

二、使用说明
	   1. 转换字库，操作步骤如下：
	      1). 选择一个您要转换的矢量字体文件(*.ttf)。
                         先将c:\windows\fonts 目录下的字体文件拷贝（ctrl+c）出来,然后本软件即可选择。
                         建议去网上找一个ArialUni.ttf字库（可找本人提供），目前linux系统用的就是这个，字符非常全面。
	            下载地址： http://ishare.iask.sina.com.cn/f/4942778.html；
	       2). 选择编码类型(MBCS or Unicode)，根据需求而定。
	      3). 选择字体大小，根据需求而定，目前只支持16，24，32，40，48，56，本软件可根据需求而改成大字体 （ > 56 ）。
	      4). 选择需要转换的字符集(支持多选)，根据需求而定。比如：我要用到简体中文，则必须选简体中文，同时还可选其它。
	      5). 选择输出文件。(BIN 文件始终默认输出，其它可选）
	      6). 选择输出目录，即将您生成的文件存放到您选择的这个目录中。
	      7). 点击 build 按钮，稍等片刻，即可生成您所想要的字库文件。

	      注意： 如果您选择的是MBCS 编码方式，又有选择多个字符集，则会输出多份上述文件。
	             如果您选择的是NICODE编码方式，不论你选多少个字符集，都只会输出一份上述文件。
	             
	             如果生成字库失败，则有可能你选择的字体文件(*.TTF)原本就不包含该字符集的字符信息。 比如：宋体中不存在韩文字符，即用宋体生成的字库无法支持韩文显示。
	             参考办法： 对照系统自带的字符映射表，里面就可以选择不同的字体，字符集（打开“高级查看”）进行参照。
	             开启字符映射表的方法：
	             1. 以命令方式运行开启，直接键入 "charmap"即可。
	             2. 程序-->附件-->系统工具--->字符映射表
	    
	   2. 字库预览，操作步骤如下：
	      1). 选择一个您要预览的字库文件（*.bin）。将会自动打开分析出其编码类型，点阵大小，包含的字符集。
	      2). 在 goto code：后面的编辑框中，输入您要查看字符的编码(如果当前选择的字库*.BIN 是unicode编码，则输入unicode码，否则输入mbcs 编码），回车后即可看到其显示效果，还可得知其字符实际显示宽度。
	 
	          另外，支持缩放预览。 拖动滑动条，可以放大缩小其预览效果。
	        
	   3. 注册  

	      在没有注册的情况下，只支持16点阵字库的转换，注册后可以支持24，32，40，48，56 ，还可根据需要修改到支持其它点阵的字体。

	      注册方法： 点击 "Aoubt..." 按钮，则会弹出一个对话框，再点击 "注册..." 按钮根据提示操作即可。	 		


三、功能描述

     1.支持所有 windows 字符集，详情如下：

	CP932,    日文Shift-JIS， 如：日语
	CP936,    简体中文GBK，   如：中文(中华人民共和国), 中文(香港特别行政区), 中文(新加坡)
	CP949,    韩文，          如：朝鲜语    
	CP950,    繁体中文Big5，  如；中文(台湾), 中文(澳门特别行政区)
	CP874,    泰文，          如：泰语
	CP1250,   中欧，          如：捷克语,匈牙利语,波兰语,罗马尼亚语,克罗地亚语,斯洛伐克语,阿尔巴尼亚语,斯洛文尼亚语,塞尔维亚语(拉丁文)
	CP1251,   西里尔文，      如：保加利亚语,俄语,乌克兰语,比利时语,马其顿语(FYROM),哈萨克语,吉尔吉斯语,鞑靼语,蒙古语,阿塞拜疆语,乌兹别克语,塞尔维亚语
	CP1252,   西欧(拉丁文I)， 如：加泰隆语,丹麦语,德语,英语,西班牙语,芬兰语,法语,冰岛语,意大利语,荷兰语,挪威语,葡萄牙语,印度尼西亚语,巴士克语,南非语,法罗语,马来语,斯瓦希里语,加里西亚语,瑞典语
	CP1253,   希腊文， 			  如：希腊语  
	CP1254,   土耳其文，      如：土耳其语,阿塞拜疆语,乌兹别克语
	CP1255,   希伯来文，      如：希伯来语  
	CP1256,   阿拉伯文，      如：乌都语,波斯语,阿拉伯语(伊拉克,埃及,利比亚,阿尔及利亚,摩洛哥,突尼斯,阿曼,也门,叙利亚,约旦,黎巴嫩,科威特,阿联酋,巴林,卡塔尔)
	CP1257,   波罗的海文，    如：爱沙尼亚语,拉脱维亚语,立陶宛语，
	CP1258,   越南，          如：越南语
	unicode   可以由上述字符集根据需求自由合成。

     2. 支持 BIN(*.bin), TXT(*.txt), BMP(*.bmp) 文件输出。

      A. BIN 文件，即字库文件（必生成）：存储的是我们最终需要用到的点阵字库信息。其文件结构由四大部分组成：文件头、段信息、检索表、点阵信息。

	     1). 文件头，指的是文件的前十六个字节（BYTE),描述信息如下结构：

	  typedef struct tagFontLibHeader{
			BYTE	magic[4];	//'U'(or 'M'), 'F', 'L', X        'U'(or 'M')---Unicode(or MBCS) Font Library, X: 表示版本号. 分高低4位。如 0x12表示 Ver 1.2
			DWORD Size;			/* File total size */
			BYTE	nSection; //MBCS:是否包含检索表。 Unicode：共分几段数据
			BYTE	YSize;    /* height of font  */  			
			WORD	wCpFlag;    // codepageflag:  bit0~bit13 每个bit分别代表一个CodePage 标志，如果是1，则表示当前CodePage 被选定，否则为非选定。
			char	reserved[4];	  // 预留字节	
		} FL_Header;
			
	     2). 段信息，只针对 UNICODE 编码有效，占字节数：nSection*sizeof(FL_SECTION_INF)。结构如下：

		typedef struct tagFlSectionInfo{
			WORD  First;         /* first character               */
			WORD  Last;          /* last character                */
			DWORD OffAddr;      /* 指向的是当前SECTION包含的 UFL_CHAR_INFO第一个字符信息的起始地址 */
		} FL_SECTION_INF, *PFL_SECTION_INF;
				
			
	     3). 检索表，只针对非等宽的MBCS（不包含简中、繁中、日文、韩文，因这些都将等宽处理，故无需检索表）和 UNICODE 字库有效。

		typedef struct tagUflCharInfo{
			#ifdef	SUPPORT_MAX_FONT        // 如采用大字体结构，最大可支持248点阵
				DWORD	 OffAddr;      // 当前字符点阵数据的起始地址
				BYTE	 Width;       // 字符点阵的像素的宽度
			#else
				DWORD	 OffAddr	: 26;      // 当前字符点阵数据的起始地址
				DWORD	 Width	: 6;       // 字符点阵的像素的宽度( 目前最大支持 56 点阵）
			#endif
		} UFL_CHAR_INDEX;

		如果是非等宽的MBCS字库，则占字节数为：0xff * sizeof（UFL_CHAR_INDEX）；
		如果是Unicode字库，则占字节数为：((xxx[0].Last - xxx[0].First + 1)+...+(xxx[nSection-1].Last - xxx[nSection-1].First + 1)) * sizeof（UFL_CHAR_INDEX）;
				
	     4). 点阵信息，即当前所有包含字符集中字符的点阵信息集合。数据存储方式为：横向高到底位存储。如： 10110011 00011010 即为 B3. 1A
			 
	     
           例如：显示编码 code = xxxx 的字符。分为以下三种情况，分别操作步骤如下：
				 
		    (1). 非等宽的MBCS字库
		            a. 先读出FL_Header信息；
		            b. 根据这个sizeof（FL_Header） + code * 2找到code的 UFL_CHAR_INDEX信息；
		            c. 根据UFL_CHAR_INDEX的OffAddr再找到当前code的点阵信息；
		            d. 最后根据FL_Header.Ysize、UFL_CHAR_INDEX.Width、以及点阵信息即可show出当前字符。
		    (2). 等宽的 MBCS字库 （包括简中、繁中、日文、韩文）
		            a. 先读出FL_Header信息；
       		      b. 计算出code在当前字符集中的索引值（index），然后根据这个sizeof（FL_Header） + index * (FL_Header.Ysize/8*FL_Header.Ysize)找到code的点阵信息；
       		      c. 然后根据FL_Header.Ysize与点阵信息即可show当前字符。
			       			
			  计算出当前code在你当前字符集（codepage）中位置,即索引值。此函数主要针对MBCS编码中的简中，繁中，日文，韩文，
			  static long GetPosWithMbcs(UINT code, UINT codepage)
			  {
				long lIdx = -1;
							
				BYTE R = (code >> 8) & 0xFF;   //区码
				BYTE C = code & 0xFF;   //位码
									
				switch(codepage)
				{
				case CP932:    // 日文
					if(R >= 0x81 && R <= 0x9F)
					{
						if(C >= 0x40 && C <= 0x7E)
							lIdx = (R-0x81)*188 + (C-0x40);  //188 = (0x7E-0x40+1)+(0xFC-0x80+1); 			
						else if(C >= 0x80 && C <= 0xFC)
							lIdx = (R-0x81)*188 + (C-0x80)+63;  // 63 = 0x7E-0x40+1;			
					}
					else if(R >= 0xE0 && R <= 0xFC)
					{
						if(C >= 0x40 && C <= 0x7E)
							lIdx = 5828 + (R-0xE0)*188 + (C-0x40);  // 5828 = 188 * (0x9F-0x81+1);
						else if(C >= 0x80 && C <= 0xFC)
							lIdx = 5828 + (R-0xE0)*188 + (C-0x80)+63;
					}
					break;
									
				case CP936:       // 简中
					if((R >= 0xA1 && R <= 0xFE) && (C >= 0xA1 && C <= 0xFE))
						lIdx = (R-0xa1)*94 + (C-0xa1);  //94 = (0xFE-0xA1+1); 
					break;
									
				case CP949:       // 韩文
					if(R >= 0x81)
					{
						if(C >= 0x41 && C <= 0x7E)
							lIdx = ((R-0x81) * 188 + (C - 0x41));   // 188 = (0x7E-0x41+1)+(0xFE-0x81+1);
						else if(C >= 0x81 && C <= 0xFE)
							lIdx = ((R-0x81) * 188 + (C - 0x81) + 62);  // 62 = (0x7E-0x41+1);
					}
					break;
									
				case CP950:        // 繁中
					if(R >= 0xA1 && R <= 0xFE) 
					{
						if(C >= 0x40 && C <= 0x7E)
							lIdx = ((R-0xa1)*157+(C-0x40));   // 157 = (0x7E-0x40+1)+(0xFE-0xA1+1);
						else if(C >= 0xA1 && C <= 0xFE)
							lIdx = ((R-0xa1)*157+(C-0xa1)+63);  // 63 = (0x7E-0x40+1);
					}
					break;
				default:
					break;
				}
				return lIdx;
			}
			       			
		    (3). Unicode字库 （可以包括所有字符集）
		         a. 先读出FL_Header信息；
		         b. 分析当前字符在第几段,比如在第n段，就可根据这个xxx[n].OffAddr+（code - xxx[n].First）* sizeof（UFL_CHAR_INDEX）找到字符索引信息(UFL_CHAR_INDEX)；
		         c. 根据UFL_CHAR_INDEX的OffAddr再找到当前code的点阵信息；
	           d. 最后根据FL_Header.Ysize、UFL_CHAR_INDEX.Width、以及点阵信息即可show出当前字符。
			       			
			
	    B. TXT 文件（可选择生成）： 存储的是当前字库包含字符的字模显示效果。详见转换后结果。

	    C. BMP 文件（可选择生成）： 是将当前字库中所有字符点阵信息整合成的一个位图文件。（只针对 MBCS 编码有效）详见转换后结果。
	    
	    
		 
四、如何从字库文件（*.bin)中获取点阵信息？

		由于选择的编码类型（MBCS 或 Unicode）以及字符集不同，则输出的字库文件所包含的数据段也会不同。如下例表：

    数据段         MBCS-CJK         MBCS-非等宽          Unicode
    -------------------------------------------------------------------
    文件头            Y                Y                    Y
    段信息            N                N                    Y
    检索表            N                Y                    Y
    点阵信息          Y                Y                    Y
    
    Y:  包含           
    N： 不包含

注释： 
   MBCS: MultiByteCharset，即多字节字符集（本地字符集）。 
   CJK： China，Japan，Korea，即中（简体，繁体）日韩字符集。
   非等宽： 每个字符的显示宽度不等。 如字符'i'，'M'。 除了 CJK 外，其它都默认为非等宽字符集。
   Unicode: 即统一编码（宽字节字符集）
   
具体举例解析如下：

    注意：
    a. 数据都是低位在前，高位在后； 
    b. 宽高都以像素为单位；
    c. 字符集从低到高顺序分别为：日文，简中，韩文，繁中，泰文，中欧，西里尔，西欧，希腊，土耳其文，希伯来文，阿拉伯文，波罗的海文，越南文；
    
		A. MBCS-CJK (等宽）
		
		00000000h: 4D 46 4C 10 50 FE 03 00 00 10 02 00 00 00 00 00 
		00000010h: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    00000020h: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    00000030h: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    00000040h: 00 00 00 00 30 00 18 00 0C 00 04 00 00 00 00 00
		...
		
		解析如下：
		1）. 文件头 ( 前 16 Byte ）
    
    4D 46 4C 10 -- 标识头，判断是否为合法的字库文件。     
                   4D = 'M'， 表示该文件为 MBCS 编码格式的字库文件。
                   46 = 'F'， 4C = 'L'
                   10 表示该字库文件版本信息为： Version 1.0
    50 FE 03 00 -- 文件总长度
    00          -- 是否包含检索表。 0-标识无检索表
    10          -- 字体高度 （宽高都以像素为单位） 0x10 == 16
    02 00       -- 选择的字符集标志位。 1-标识选择， 0-标识未选择.   故得出当前选择为： 简中字符集。
    00 00 00 00 -- 预留字节    
     	
   	2). 点阵信息
   	因为GB2312 的首个字符：0xA1A1， 它的点阵数据起始地址为 0x10，数据长度为：（（字体高度+7）/8）* 字体高度 = ((16+7）/8)*16 = 32.
   	故取如下 16 字节，即为字符0xA1A1的点阵信息。
   	00000010h: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    00000020h: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   	
   	同理如下即为字符0xA1A2的点阵信息。 
   	00000030h: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    00000040h: 00 00 00 00 30 00 18 00 0C 00 04 00 00 00 00 00
    
    
    由于等宽，所以所有字符的点阵数据长度都为：（（字体高度+7）/8）* 字体高度  = ？
		
		
	  B. MBCS-非等宽 
    Sample 子目录下的文件arialuni16_CP1252.bin, 文件内容如下：
    
    00000000h: 4D 46 4C 10 90 1A 00 00 01 10 80 00 00 00 00 00 
    00000010h: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    00000020h: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    00000030h: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    00000040h: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    00000050h: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    00000060h: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    00000070h: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    00000080h: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    00000090h: 10 04 00 10 20 04 00 10 30 04 00 18 40 04 00 24
    ...
    00000410h: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    00000420h: 00 00 40 40 40 40 40 40 40 40 00 40 40 00 00 00
    ....
    
    解析如下： 
    1）. 文件头 ( 前 16 Byte ）
    
    4D 46 4C 10 -- 标识头，判断是否为合法的字库文件。     
                   4D = 'M'， 表示该文件为 MBCS 编码格式的字库文件。
                   46 = 'F'， 4C = 'L'
                   10 表示该字库文件版本信息为： Version 1.0
    90 1A 00 00 -- 文件总长度
    01          -- 是否包含检索表。 1-标识有检索表
    10          -- 字体高度  0x10 == 16
    80 00       -- 选择的字符集标志位。 1-标识选择， 0-标识未选择. 故得出当前选择为： 西欧字符集。
    00 00 00 00 -- 预留字节
    
    2）. 检索表 
    从 00000010h 开始，每 4 个字节表示一个字符的检索信息， 且从字符 0x0 开始。故空格字符（' '）的检索信息（00000090h）为：10 04 00 10
    即得出一个 32 位数为： 0x10000410（十六进制） --- （00010000 00000000 00000100 00010000）. 
    高 6 位，表示当前字符的宽度。 故得出 000100 -- 4 （字库宽度为 4 ）
    低 26 位， 表示当期字符的点阵信息的偏移地址。故得出 00 00000000 00000100 00010000 -- 0x410 （点阵信息的起始地址为 0x410)
   	
   	3). 点阵信息
   	由于空格字符的起始地址为 0x410，且数据长度为：（（字体宽度+7）/8）* 字体高度 = ((4+7）/8)*16 = 16.
   	故取如下 16 字节，即为空格字符的点阵信息。
   	00000410h: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   	
   	同理如下即为字符'!' 的点阵信息。 
   	00000420h: 00 00 40 40 40 40 40 40 40 40 00 40 40 00 00 00
   	
   	
   	C. Unicode  (具体请参阅文件 .\Demo\ReadUnicode.c）
   	
   	00000000h: 55 46 4C 10 28 AB 07 00 01 10 81 00 00 00 00 00 
    00000010h: 20 00 FF FF 18 00 00 00 98 FF 03 10 A8 FF 03 10
    ...
    0003ff90h: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
    0003ffa0h: 00 00 00 00 00 00 00 00 00 00 40 40 40 40 40 40
    0003ffb0h: 40 40 00 40 40 00 00 00 00 00 48 48 48 48 00 00
    ...
   
      
    解析如下： 
    1）. 文件头 ( 前 16 Byte ）
    
    55 46 4C 10 -- 标识头，判断是否为合法的字库文件。     
                   55 = 'U'， 表示该文件为 UNICODE 编码格式的字库文件。
                   46 = 'F'， 4C = 'L'
                   10 表示该字库文件版本信息为： Version 1.0
    28 AB 07 00 -- 文件总长度
    01          -- 包含几个Section。 1- 1 Section (  在不包括CJK时，会分成3 Section）
    10          -- 字体高度  0x10 == 16
    81 00       -- 选择的字符集标志位。 1-标识选择， 0-标识未选择. 故得出当前选择为： 日文+西欧字符集。
    00 00 00 00 -- 预留字节
    
    2）. 段信息 (n section * sizeof(FL_SECTION_INF) = 1 * 8 = 8))
    20 00 -- First character
    FF FF -- Last character
    18 00 00 00 -- OffAddr;      /* 指向的是当前SECTION中First character对应的 UFL_CHAR_INDEX信息的起始地址 */    
    
    3）. 检索表 （(Section[0].Last - Section[0].First + 1) * 4 + (Section[n-1].Last - Section[n-1].First + 1) * 4)
    每 4 个字节表示一个字符的检索信息， 且从字符Section[0].First 开始。故字符0x20的检索信息（起始地址 = 
    （字符的unicode码 - Section[x].First） × 4 + Section[x].OffAddr,  x 为当前字符处在的section索引值，可判断得出。）为：98 FF 03 10
    即得出一个 32 位数为： 0x1003FF98（十六进制） --- （00010000 00000011 11111111 10011000）. 
    高 6 位，表示当前字符的宽度。 故得出 000100 -- 4 （字库宽度为 4 ）
    低 26 位， 表示当期字符的点阵信息的偏移地址。故得出 00 00000011 11111111 10011000 -- 0x3FF98 （点阵信息的起始地址为 0x3FF98)
   	
   	3). 点阵信息
   	由于空格字符的起始地址为 0x3FF98，且数据长度为：（（字体宽度+7）/8）* 字体高度 = ((4+7）/8)*16 = 16.
   	故取如下 16 字节，即为空格字符的点阵信息。
   	0003ff98h: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
   	
   	同理如下即为字符0x21 的点阵信息。 
   	0003ffA8h: 00 00 40 40 40 40 40 40 40 40 00 40 40 00 00 00
   	
                   
   

	但愿它能给您带来一定帮助。如有疑问，或发现有不妥的地方可以给我发邮件。诚谢！
		
	==================================================================================
            
				  宁馨自由工作室

			    MAIL: 9599598@qq.com; wujianguo789@126.com

			    MSN: wujianguo19@hotmail.com
								
                                              BLOG: http://blog.sina.com.cn/wujianguo789 ( 版本更新，将在此处提示）
			    










